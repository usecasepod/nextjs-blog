<!DOCTYPE html><html lang="en"><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><link rel="apple-touch-icon" sizes="180x180" href="/favicons/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicons/favicon-16x16.png"/><link rel="manifest" href="/favicons/site.webmanifest"/><link rel="mask-icon" href="/favicons/safari-pinned-tab.svg" color="#000000"/><link rel="shortcut icon" href="/favicons/favicon.ico"/><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><meta name="theme-color" content="#000"/><link rel="alternate" type="application/rss+xml" href="/feed.xml"/><meta name="description" content="A statically generated blog example using Next.js and Markdown."/><meta property="og:image" content="https://og-image.vercel.app/Next.js%20Blog%20Starter%20Example.png?theme=light&amp;md=1&amp;fontSize=100px&amp;images=https%3A%2F%2Fassets.vercel.com%2Fimage%2Fupload%2Ffront%2Fassets%2Fdesign%2Fnextjs-black-logo.svg"/><title>Use Case Podcast | Exploring MVU Part 2: Composition</title><meta name="next-head-count" content="15"/><link rel="preload" href="/nextjs-blog/_next/static/css/b9fe46af80a3b1d3.css" as="style"/><link rel="stylesheet" href="/nextjs-blog/_next/static/css/b9fe46af80a3b1d3.css" data-n-g=""/><link rel="preload" href="/nextjs-blog/_next/static/css/cf121497002c184d.css" as="style"/><link rel="stylesheet" href="/nextjs-blog/_next/static/css/cf121497002c184d.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/nextjs-blog/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/nextjs-blog/_next/static/chunks/webpack-2a7e57d41ff54a86.js" defer=""></script><script src="/nextjs-blog/_next/static/chunks/framework-5f4595e5518b5600.js" defer=""></script><script src="/nextjs-blog/_next/static/chunks/main-a0853fbc3d9f629b.js" defer=""></script><script src="/nextjs-blog/_next/static/chunks/pages/_app-ff4c1a49d0216aaf.js" defer=""></script><script src="/nextjs-blog/_next/static/chunks/893-e5f5e7f2bb4d83ff.js" defer=""></script><script src="/nextjs-blog/_next/static/chunks/pages/posts/%5Bslug%5D-b6afa1bc5bae314d.js" defer=""></script><script src="/nextjs-blog/_next/static/W8uwEbnihAL2hkzDM9xWg/_buildManifest.js" defer=""></script><script src="/nextjs-blog/_next/static/W8uwEbnihAL2hkzDM9xWg/_ssgManifest.js" defer=""></script><script src="/nextjs-blog/_next/static/W8uwEbnihAL2hkzDM9xWg/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><div class="min-h-screen"><main><div class="container mx-auto px-5"><h2 class="text-2xl md:text-4xl font-bold tracking-tight md:tracking-tighter leading-tight mb-20 mt-8"><a class="hover:underline" href="/">Blog</a>.</h2><article class="mb-32"><h1 class="text-6xl md:text-7xl lg:text-8xl font-bold tracking-tighter leading-tight md:leading-none mb-12 text-center md:text-left">Exploring MVU Part 2: Composition</h1><div class="hidden md:block md:mb-12"><div class="flex items-center"><div class="text-xl font-bold">Austin Webre</div></div></div><div class="mb-8 md:mb-16 sm:mx-0"></div><div class="max-w-2xl mx-auto"><div class="block md:hidden mb-6"><div class="flex items-center"><div class="text-xl font-bold">Austin Webre</div></div></div><div class="mb-6 text-lg"><time dateTime="2020-05-24">May	24, 2020</time></div></div><div class="max-w-2xl mx-auto"><div class="markdown-styles_markdown__h_8de"><p>So a couple days have come and gone and I'm still riding high on my experience with the MVU pattern. I'm struggling some with the syntax of F#, but I'm getting it bit by bit and even learning to love some aspects of it. That being said, the sample app I went through last time did nothing but peak my interest. It felt really smooth and easy to reason about, but "Counters" always are, right? So the next logical question is, how do we make this work for a more complicated situation?</p>
<p>I did some digging, but all the examples I could find simply stuffed more code into the view. Which is fine for smaller tasks, but thats just not sustainable for an app with multiple pages and navigation. So I started googling but ended up going in all the wrong directions. Eventually, I came across something in the docs for Elmish (an F# MVU-like framework) that really opened things up. In the example, there's a <code>Counter</code> module that is used by a <code>CounterList</code> module which reuses the <code>Counter</code>'s model, update, and view logic. I could post the example and we could go through it, but I thought this might be a good chance to make some progress on <code>commutr_v2</code>.</p>
<p>I'm going to start by trying to recreate the first page of the <code>commutr</code> app, which displays all the vehicles that you can track. Now in a future version of this app, we're going to skip this step if the user has marked a "Primary" vehicle. So really, this work is mostly going to be useless if it ever gets off the ground. But its a good simple case and a good first place to start. My first instinct is to follow the counter example I explained above. So we'll start with the smallest part first.</p>
<h1>VehicleItem.fs</h1>
<pre><code>namespace commutr_v2

open Fabulous
open Fabulous.XamarinForms
open Xamarin.Forms

module VehicleItem =
    type Model =
      { Id : int
        Make : string
        Model : string
        Year : int
        IsPrimary : bool }

    type Msg =
        | TogglePrimary of bool

    let init (initModel : Model) = initModel

    let update msg model =
        match msg with
        | TogglePrimary isPrimary -> { model with IsPrimary = isPrimary }

    let view (model: Model) dispatch =
        View.StackLayout(padding = Thickness 20.0, verticalOptions = LayoutOptions.Center, orientation = StackOrientation.Horizontal,
            children = [
                View.Label(text = model.Make, horizontalOptions = LayoutOptions.Center, width=200.0, horizontalTextAlignment=TextAlignment.Center)
                View.Label(text = model.Model, horizontalOptions = LayoutOptions.Center, width=200.0, horizontalTextAlignment=TextAlignment.Center)
            ])
</code></pre>
<p>This is pretty straight forward, so I won't go in too much detail. The plan here is to output a view that can be used as a child of a <code>CollectionView</code>. So we have our model which represents a vehicle, the update which can set whether the vehicle in question is "Primary", and the view which puts it all together. We may come back to this later, as I'm not entirely sure what actions will need to be handled here and what actions will need to be handled in parent components, but this seems like it handles everything I need for the moment.</p>
<p>Now that we have the smallest piece set up, lets move one step higher.</p>
<h1>VehicleListing.fs</h1>
<pre><code>module VehicleListing =
    type Model = {
        Vehicles : VehicleItem.Model list
        SelectedVehicle : Option&#x3C;VehicleItem.Model>
        }

    type Msg =
        | Insert
        | Remove
        | Modified of int * VehicleItem.Msg
        | SelectVehicle of int

    let initModel : Model = { Vehicles = [
                            {Id = 1; Make = "Honda"; Model = "Accord"; Year = 2005; IsPrimary = false}
                            {Id = 2; Make = "Honda"; Model = "Insight"; Year = 2019; IsPrimary = true}
                            ];
                            SelectedVehicle = None }

    let init() = initModel

    let update msg model =
        match msg with
        | Insert -> model //TODO: Make this do something
        | Remove -> model //TODO: Make this do something
        | Modified (pos, itemMessage) -> { model with Vehicles = model.Vehicles
                                                        |> List.mapi (fun i itemModel ->
                                                        if i = pos then
                                                            VehicleItem.update itemMessage itemModel
                                                        else
                                                            itemModel)}
        | SelectVehicle pos -> {model with SelectedVehicle = Some(model.Vehicles.Item(pos))}

    let view (model : Model) dispatch =
        let items = model.Vehicles |> List.mapi(fun pos itemModel ->
                             VehicleItem.view
                                itemModel
                                (fun msg -> dispatch (Modified (pos, msg))))
        View.CollectionView(items)
</code></pre>
<p>Now this is clearly a work in progress, but I wanted to map out where I'm heading while simultaneously getting the most simple case working first. There are three novel things that are happening here. The first is that part of the Model for this module is a list of models from the <code>VehicleItem</code> module. Model, module, model, module... bleh.</p>
<p>Anyway, the second is in <code>update</code>. You'll notice the arguments for the <code>Modified</code> case are <code>pos</code> (an integer representing the position of the requested item in the array - aka its index) and <code>itemMessage</code> which is of type <code>VehicleItem.Msg</code>. Those arguments are then used to update the model that matches the correct position using <code>VehicleItem.update</code>. So all we're doing is routing the message back to the appropriate update function so that the result is a list of updated <code>VehicleItem.Model</code>s. And since our <code>update</code> functions are pure, we don't need a specific instance of anything, just pass the model and the message and the result will be the updated model.</p>
<p>The last novel thing is in (you guessed it) the view. We get a list of items by mapping the List of <code>VehicleItem.Model</code> in our model to a list of Stack Layout Views via the <code>VehicleItem.view</code> function. There's something really interesting that we're doing here that makes this work. We're hijacking the <code>dispatch</code> function so that the <code>Modified</code> message gets sent instead. Its then up to our <code>Modified</code> message to update the appropriate item (using <code>VehicleItem.update</code> as we previously saw).</p>
<p>Hopefully that makes sense.</p>
<p>Now, you may notice that I defined a <code>SelectVehicle</code> message that will handle selection (and potentially navigation). I did this mostly just to work out how that might hypothetically look. It isn't used here because I realized that <code>CollectionView</code> requires you to wrap each item in a <code>SwipeView</code>, so we may have to move that logic down somehow. Or maybe not. I haven't gotten that far yet.</p>
<p>Back to making the simplest case work.</p>
<h1>Wiring It All Up</h1>
<p>So now that we have the Vehicle List worked out, lets tie it all together in the root <code>App</code> module.</p>
<pre><code>namespace commutr_v2

open System.Diagnostics
open Fabulous
open Fabulous.XamarinForms
open Fabulous.XamarinForms.LiveUpdate
open Xamarin.Forms

module App =
    type Model =
      { Vehicles : VehicleListing.Model }

    type Msg =
        | VehicleListUpdated of VehicleListing.Msg
        | RefreshVehicles

    let initModel = { Vehicles = VehicleListing.init() }

    let init () = initModel, Cmd.none

    let update msg model =
        match msg with
        | VehicleListUpdated listMsg -> {model with Vehicles = VehicleListing.update listMsg model.Vehicles}, Cmd.none
        | RefreshVehicles -> {model with Vehicles = VehicleListing.init()}, Cmd.none

    let view (model: Model) (dispatch : Dispatch&#x3C;Msg>) =
        let vehicleList = VehicleListing.view
                            model.Vehicles
                            (fun msg -> dispatch (VehicleListUpdated msg))
        View.ContentPage(
          content = View.StackLayout(padding = Thickness 20.0, verticalOptions = LayoutOptions.Center,
            children = [
                vehicleList
            ]))

    // Note, this declaration is needed if you enable LiveUpdate
    let program = XamarinFormsProgram.mkProgram init update view

type App () as app =
    inherit Application ()

    let runner =
        App.program
#if DEBUG
        |> Program.withConsoleTrace
#endif
        |> XamarinFormsProgram.run app
</code></pre>
<p>So this is not all that unsimilar to the <code>VehicleListing</code>. We make the child model part of our model and use the child's update and view logic in our own. The result isn't the prettiest, but it displays, so... a job well done?</p>
<p><img src="/assets/posts/mvu-composition/wired-up-ui.png" alt="Wired Up UI"></p>
<p>Clearly there are some changes that need to be made. For instance, not all the vehicle data is displayed and (to be quite frank) this UI is trash. So lets see if we can't make this thing just a little bit more appealing. The good news is this will likely involve mostly just tweaking the view code a little bit. So lets see what we can do...</p>
<p>We'll change the <code>view</code> function of the <code>VehicleListing</code> to be the following:</p>
<pre><code>    let view (model: Model) dispatch =
        View.StackLayout
            (padding = Thickness 5.0,
             children =
                 [ View.Frame
                     (hasShadow = false,
                      backgroundColor = AppColors.ghostWhite,
                      padding = Thickness 10.0,
                      content =
                          View.FlexLayout
                              (margin = Thickness 10.0,
                               verticalOptions = LayoutOptions.Center,
                               horizontalOptions = LayoutOptions.Center,
                               alignItems = FlexAlignItems.Center,
                               justifyContent = FlexJustify.SpaceEvenly,
                               direction = FlexDirection.Row,
                               children =
                                   [ View.SKCanvasView
                                       (paintSurface =
                                           (fun args ->
                                               let info = args.Info
                                               let surface = args.Surface
                                               let canvas = surface.Canvas

                                               canvas.Clear()

                                               use paint =
                                                   new SkiaSharp.SKPaint(Style = SkiaSharp.SKPaintStyle.Fill,
                                                                         Color =
                                                                             (if model.IsPrimary then
                                                                                 AppColors.mandarin.ToSKColor()
                                                                              else
                                                                                  AppColors.silverSandLight.ToSKColor()),
                                                                         StrokeWidth = 5.0f)

                                               canvas.DrawCircle
                                                   (float32 (info.Width / 2), float32 (info.Height / 2), 10.0f, paint)))
                                     View.Label(text = model.Year.ToString())
                                     View.Label(text = model.Make)
                                     View.Label(text = model.Model) ])) ])
</code></pre>
<p>Now thats quite a big difference, so lets break it down real quick.</p>
<p>The basic layout is a <code>StackLayout</code> with a single <code>Frame</code> as the child. This is done so that we can create space between list elements via padding. The <code>Frame</code>'s content is a <code>FlexLayout</code> which allows us to evenly space the elements horizontally. Finally, we have a dot drawn via SkiaSharp that indicates the which is the primary, along with the reast of the info for the vehicle.</p>
<p>The result looks like this:</p>
<p><img src="/assets/posts/mvu-composition/spiffy-vehicle-list.png" alt="Spiffy Vehicle List"></p>
<p>I decided to conditionally change the color of the primary indicator instead of hiding it so that things will continue to line up. The alignment and layout isn't perfect, but it feels pretty good so I'm going to leave it alone for now and move on to something more interesting. Lets try to wire up a <code>SwipeView</code> so that we can swipe on individual items and mark them as primary.</p>
<h1>Toggle Primary</h1>
<p>So before we get into the code that changed, I want to say that this was really quite painless to set up. In fact, most of the changes I've made were more improvments than they were "making it work". This is largely due to the nature of MVU. Since I spent a little bit of time mapping out what updates I wanted, the logic required to update the model was already there, it just took a little bit of work to finish putting it together. That being said lets dive in.</p>
<pre><code>    let update msg model =
        match msg with
        | Insert -> model //TODO: Make this do something
        | Remove -> model //TODO: Make this do something
        | Modified (pos, itemMessage) ->
            match itemMessage with
            | VehicleItem.Msg.TogglePrimary isPrimary ->
                { model with
                      Vehicles =
                          model.Vehicles
                          |> List.mapi (fun i itemModel ->
                              if i = pos then
                                  VehicleItem.update itemMessage itemModel
                              else
                                  (if isPrimary &#x26;&#x26; itemModel.IsPrimary
                                   then VehicleItem.update (VehicleItem.TogglePrimary(false)) itemModel
                                   else itemModel)) }
        | SelectVehicle pos ->
            { model with
                  SelectedVehicle = Some(model.Vehicles.Item(pos)) }

    let view (model: Model) dispatch =
        let items =
            model.Vehicles
            |> List.mapi (fun pos itemModel ->
                View.SwipeView
                    (backgroundColor = AppColors.silverSandLight,
                     rightItems =
                         View.SwipeItems
                             (items =
                                 [ View.SwipeItem
                                     (text = (if not itemModel.IsPrimary then "Primary" else "Not Primary"),
                                      backgroundColor =
                                          (if not itemModel.IsPrimary then
                                              AppColors.mandarin
                                           else
                                               AppColors.silverSandMediumDark),
                                      command =
                                          fun () ->
                                              dispatch
                                                  (Modified(pos, VehicleItem.TogglePrimary(not itemModel.IsPrimary)))) ]),
                     content = VehicleItem.view itemModel (fun msg -> dispatch (Modified(pos, msg)))))

        View.CollectionView(items)
</code></pre>
<p>Let's start by looking at the <code>view</code> function. Instead of mapping our <code>VehicleItem.Model</code>'s directly to their <code>view</code> function, we wrap them in a <code>SwipeView</code>. I think it would have also been feasible to implement the swipe view one step down in the body of <code>VehicleItem.view</code>, but it felt right to keep <code>VehicleItem</code> to strictly displaying the Vehicle information.</p>
<p>You'll notice that the <code>SwipeView</code> contains a <code>SwipeItem</code> which has some conditional rendering of the text and background color. This is just so that we can distinguish between adding and removing the "Primary" status. I used the <code>SwipeItem</code>'s command property to fire dispatch and send the appropriate message. Really and truly, I realized that my <code>Modified</code> message handling is a bit more complicated than it needs to be right now. This is because I'm assuming that <code>VehicleItem</code> will eventually require additional messages (for things like updating the Make, Model) and that that logic will need to be <em>different</em> from the logic that handles IsPrimary.</p>
<p>This is primarily for two different reasons. One is that only one vehicle can have "Primary" status at a time, so if "Primary" status changes for one vehicle, it <em>may</em> affect the others (this is reflected in the <code>update</code> function, but we'll get to that in a minute). This is simply not true of other properties like Make, Model, and Year.</p>
<p>The second reason is actually not visible in the above code. There is a small change I made to <code>VehicleItem</code>, which basically amounts to forcing SkiaSharp to redraw the little circles on every update. This is fine for right now, because the only reason <code>VehicleItem.update</code> is called at the moment is to change <code>IsPrimary</code> which requires a redraw of the dot. However, as we add other messages, we will need to make sure we don't redraw on every update as this will result in performance hits.</p>
<p>So this is where we are UI-wise:</p>
<p><img src="/assets/posts/mvu-composition/mark-primary.gif" alt="Mark Primary UI"></p>
<p>You'll notice that selecting one as Primary makes the other not primary (if it already was). This logic is handled in our <code>update</code> function. Our <code>Modified</code> message contains the position and the <code>VehicleItem.Msg</code> we want to pass on to <code>VehicleItem.update</code>. Now we could for the time being have made <code>Modified</code> to contain the <code>TogglePrimary</code> message instead of any <code>VehicleItem.Msg</code>, because for now that's the only message that <code>VehicleItem</code> has, but as I said earlier, this will allow us to handle future scenarios where we want to edit other information. So we pattern match on <code>itemMessage</code> and handle the only existing case (where <code>itemMessage</code> is the <code>TogglePrimary</code> message).</p>
<p>We are also no longer simply calling <code>VehicleItem.update</code> on the item that matches the position we were given. We're also checking if we're setting a new item as Primary and mark any other items that are currently "Primary" to false. This will ensure that only one item is ever marked as Primary at a time.</p>
<p>Before we wrap things up, I want to mention that I <em>think</em> this validates my assumption that we can handle "Selecting" a particular vehicle item within <code>VehicleListing</code>. We should be able to call dispatch to send a selection message from a <code>SwipeItem</code>.</p>
<h1>Wrapping Up</h1>
<p>So I think this is the state I'll leave the app in for the purposes of this article. I think it gives a pretty good idea of how composition in MVU can allow us to break out parts of the UI into smaller units. So I guess the question is, what did we learn from this?</p>
<p>My first big take away is that this architecture is so straight forward that it was fairly easy for me to do a lot of planning ahead without really having a super great understanding of how all the pieces would fit together. For instance, I was pleasantly surprised by how decisions I made when creating <code>VehicleItem</code> panned out when connecting them to <code>VehicleListing</code>. The simplicity of this framework really does allow you to think clearly and accurately about what changes should and will occur to the model as well as what the resulting UI will look like.</p>
<p>I will note that I did not do any Commanding, which I think will complicate matters when it is needed, but the beautify of this framework is that its not necessary so far, so I didn't have to use it.</p>
<p>I'd also like to take this time to mention that I did have certain struggles with using additional libraries. One thing I've come to realize is that there isn't a lot of documentation for Fabulous and that examples of F# code in general are hard to find. This can make it difficult to learn, but also frustrating for someone who is used to being able to "just read the docs".</p>
<p>Another thing I'd like to note is that quite frankly, 3rd party support for F# in Xamarin.Forms basically does not exist. I had wanted to use Sharpnado's MaterialFrame so I could get the Acrylic look, but quickly found out that MaterialFrame is built to be used strictly in XAML. This was a bit disappointing, but ultimately not a big deal. My hope is that with .NET MAUI, we'll start to see some of these UI tools become more "Functional Friendly" with built in support that goes beyond data binding and MVVM.</p>
<p>I do plan to continue working on this project, but I think this will be my last blog on it for a while. I need to spend some more time digging in to F# and MVU so that I can really understand it and find some interesting ways to use it, before I can share any more insights.</p>
<p>In the meantime, go give us some listens and feel free to reach out in the comments below, on Twitter <a href="twitter.com/usecasepod">@usecasepod</a>, or <a href="mailto:usecasepod@gmail.com">via email (usecasepod@gmail.com)</a>.</p>
<p>You can also find the full repository for this app <a href="https://github.com/usecasepod/commutr_v2">on our Github</a>, but keep in mind that this is going to be a living project, so what you see in this post today may not be reflected in the current version of the app.</p>
</div></div></article></div></main></div><footer class="bg-accent-1 border-t border-accent-2"><div class="container mx-auto px-5"><div class="py-28 flex flex-col lg:flex-row items-center"><h3 class="text-4xl lg:text-5xl font-bold tracking-tighter leading-tight text-center lg:text-left mb-10 lg:mb-0 lg:pr-4 lg:w-1/2">The power is yours...</h3></div></div></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Exploring MVU Part 2: Composition","slug":"2020-05-24-mvu-composition","author":"Austin Webre","content":"\u003cp\u003eSo a couple days have come and gone and I'm still riding high on my experience with the MVU pattern. I'm struggling some with the syntax of F#, but I'm getting it bit by bit and even learning to love some aspects of it. That being said, the sample app I went through last time did nothing but peak my interest. It felt really smooth and easy to reason about, but \"Counters\" always are, right? So the next logical question is, how do we make this work for a more complicated situation?\u003c/p\u003e\n\u003cp\u003eI did some digging, but all the examples I could find simply stuffed more code into the view. Which is fine for smaller tasks, but thats just not sustainable for an app with multiple pages and navigation. So I started googling but ended up going in all the wrong directions. Eventually, I came across something in the docs for Elmish (an F# MVU-like framework) that really opened things up. In the example, there's a \u003ccode\u003eCounter\u003c/code\u003e module that is used by a \u003ccode\u003eCounterList\u003c/code\u003e module which reuses the \u003ccode\u003eCounter\u003c/code\u003e's model, update, and view logic. I could post the example and we could go through it, but I thought this might be a good chance to make some progress on \u003ccode\u003ecommutr_v2\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eI'm going to start by trying to recreate the first page of the \u003ccode\u003ecommutr\u003c/code\u003e app, which displays all the vehicles that you can track. Now in a future version of this app, we're going to skip this step if the user has marked a \"Primary\" vehicle. So really, this work is mostly going to be useless if it ever gets off the ground. But its a good simple case and a good first place to start. My first instinct is to follow the counter example I explained above. So we'll start with the smallest part first.\u003c/p\u003e\n\u003ch1\u003eVehicleItem.fs\u003c/h1\u003e\n\u003cpre\u003e\u003ccode\u003enamespace commutr_v2\n\nopen Fabulous\nopen Fabulous.XamarinForms\nopen Xamarin.Forms\n\nmodule VehicleItem =\n    type Model =\n      { Id : int\n        Make : string\n        Model : string\n        Year : int\n        IsPrimary : bool }\n\n    type Msg =\n        | TogglePrimary of bool\n\n    let init (initModel : Model) = initModel\n\n    let update msg model =\n        match msg with\n        | TogglePrimary isPrimary -\u003e { model with IsPrimary = isPrimary }\n\n    let view (model: Model) dispatch =\n        View.StackLayout(padding = Thickness 20.0, verticalOptions = LayoutOptions.Center, orientation = StackOrientation.Horizontal,\n            children = [\n                View.Label(text = model.Make, horizontalOptions = LayoutOptions.Center, width=200.0, horizontalTextAlignment=TextAlignment.Center)\n                View.Label(text = model.Model, horizontalOptions = LayoutOptions.Center, width=200.0, horizontalTextAlignment=TextAlignment.Center)\n            ])\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis is pretty straight forward, so I won't go in too much detail. The plan here is to output a view that can be used as a child of a \u003ccode\u003eCollectionView\u003c/code\u003e. So we have our model which represents a vehicle, the update which can set whether the vehicle in question is \"Primary\", and the view which puts it all together. We may come back to this later, as I'm not entirely sure what actions will need to be handled here and what actions will need to be handled in parent components, but this seems like it handles everything I need for the moment.\u003c/p\u003e\n\u003cp\u003eNow that we have the smallest piece set up, lets move one step higher.\u003c/p\u003e\n\u003ch1\u003eVehicleListing.fs\u003c/h1\u003e\n\u003cpre\u003e\u003ccode\u003emodule VehicleListing =\n    type Model = {\n        Vehicles : VehicleItem.Model list\n        SelectedVehicle : Option\u0026#x3C;VehicleItem.Model\u003e\n        }\n\n    type Msg =\n        | Insert\n        | Remove\n        | Modified of int * VehicleItem.Msg\n        | SelectVehicle of int\n\n    let initModel : Model = { Vehicles = [\n                            {Id = 1; Make = \"Honda\"; Model = \"Accord\"; Year = 2005; IsPrimary = false}\n                            {Id = 2; Make = \"Honda\"; Model = \"Insight\"; Year = 2019; IsPrimary = true}\n                            ];\n                            SelectedVehicle = None }\n\n    let init() = initModel\n\n    let update msg model =\n        match msg with\n        | Insert -\u003e model //TODO: Make this do something\n        | Remove -\u003e model //TODO: Make this do something\n        | Modified (pos, itemMessage) -\u003e { model with Vehicles = model.Vehicles\n                                                        |\u003e List.mapi (fun i itemModel -\u003e\n                                                        if i = pos then\n                                                            VehicleItem.update itemMessage itemModel\n                                                        else\n                                                            itemModel)}\n        | SelectVehicle pos -\u003e {model with SelectedVehicle = Some(model.Vehicles.Item(pos))}\n\n    let view (model : Model) dispatch =\n        let items = model.Vehicles |\u003e List.mapi(fun pos itemModel -\u003e\n                             VehicleItem.view\n                                itemModel\n                                (fun msg -\u003e dispatch (Modified (pos, msg))))\n        View.CollectionView(items)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow this is clearly a work in progress, but I wanted to map out where I'm heading while simultaneously getting the most simple case working first. There are three novel things that are happening here. The first is that part of the Model for this module is a list of models from the \u003ccode\u003eVehicleItem\u003c/code\u003e module. Model, module, model, module... bleh.\u003c/p\u003e\n\u003cp\u003eAnyway, the second is in \u003ccode\u003eupdate\u003c/code\u003e. You'll notice the arguments for the \u003ccode\u003eModified\u003c/code\u003e case are \u003ccode\u003epos\u003c/code\u003e (an integer representing the position of the requested item in the array - aka its index) and \u003ccode\u003eitemMessage\u003c/code\u003e which is of type \u003ccode\u003eVehicleItem.Msg\u003c/code\u003e. Those arguments are then used to update the model that matches the correct position using \u003ccode\u003eVehicleItem.update\u003c/code\u003e. So all we're doing is routing the message back to the appropriate update function so that the result is a list of updated \u003ccode\u003eVehicleItem.Model\u003c/code\u003es. And since our \u003ccode\u003eupdate\u003c/code\u003e functions are pure, we don't need a specific instance of anything, just pass the model and the message and the result will be the updated model.\u003c/p\u003e\n\u003cp\u003eThe last novel thing is in (you guessed it) the view. We get a list of items by mapping the List of \u003ccode\u003eVehicleItem.Model\u003c/code\u003e in our model to a list of Stack Layout Views via the \u003ccode\u003eVehicleItem.view\u003c/code\u003e function. There's something really interesting that we're doing here that makes this work. We're hijacking the \u003ccode\u003edispatch\u003c/code\u003e function so that the \u003ccode\u003eModified\u003c/code\u003e message gets sent instead. Its then up to our \u003ccode\u003eModified\u003c/code\u003e message to update the appropriate item (using \u003ccode\u003eVehicleItem.update\u003c/code\u003e as we previously saw).\u003c/p\u003e\n\u003cp\u003eHopefully that makes sense.\u003c/p\u003e\n\u003cp\u003eNow, you may notice that I defined a \u003ccode\u003eSelectVehicle\u003c/code\u003e message that will handle selection (and potentially navigation). I did this mostly just to work out how that might hypothetically look. It isn't used here because I realized that \u003ccode\u003eCollectionView\u003c/code\u003e requires you to wrap each item in a \u003ccode\u003eSwipeView\u003c/code\u003e, so we may have to move that logic down somehow. Or maybe not. I haven't gotten that far yet.\u003c/p\u003e\n\u003cp\u003eBack to making the simplest case work.\u003c/p\u003e\n\u003ch1\u003eWiring It All Up\u003c/h1\u003e\n\u003cp\u003eSo now that we have the Vehicle List worked out, lets tie it all together in the root \u003ccode\u003eApp\u003c/code\u003e module.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003enamespace commutr_v2\n\nopen System.Diagnostics\nopen Fabulous\nopen Fabulous.XamarinForms\nopen Fabulous.XamarinForms.LiveUpdate\nopen Xamarin.Forms\n\nmodule App =\n    type Model =\n      { Vehicles : VehicleListing.Model }\n\n    type Msg =\n        | VehicleListUpdated of VehicleListing.Msg\n        | RefreshVehicles\n\n    let initModel = { Vehicles = VehicleListing.init() }\n\n    let init () = initModel, Cmd.none\n\n    let update msg model =\n        match msg with\n        | VehicleListUpdated listMsg -\u003e {model with Vehicles = VehicleListing.update listMsg model.Vehicles}, Cmd.none\n        | RefreshVehicles -\u003e {model with Vehicles = VehicleListing.init()}, Cmd.none\n\n    let view (model: Model) (dispatch : Dispatch\u0026#x3C;Msg\u003e) =\n        let vehicleList = VehicleListing.view\n                            model.Vehicles\n                            (fun msg -\u003e dispatch (VehicleListUpdated msg))\n        View.ContentPage(\n          content = View.StackLayout(padding = Thickness 20.0, verticalOptions = LayoutOptions.Center,\n            children = [\n                vehicleList\n            ]))\n\n    // Note, this declaration is needed if you enable LiveUpdate\n    let program = XamarinFormsProgram.mkProgram init update view\n\ntype App () as app =\n    inherit Application ()\n\n    let runner =\n        App.program\n#if DEBUG\n        |\u003e Program.withConsoleTrace\n#endif\n        |\u003e XamarinFormsProgram.run app\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSo this is not all that unsimilar to the \u003ccode\u003eVehicleListing\u003c/code\u003e. We make the child model part of our model and use the child's update and view logic in our own. The result isn't the prettiest, but it displays, so... a job well done?\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/posts/mvu-composition/wired-up-ui.png\" alt=\"Wired Up UI\"\u003e\u003c/p\u003e\n\u003cp\u003eClearly there are some changes that need to be made. For instance, not all the vehicle data is displayed and (to be quite frank) this UI is trash. So lets see if we can't make this thing just a little bit more appealing. The good news is this will likely involve mostly just tweaking the view code a little bit. So lets see what we can do...\u003c/p\u003e\n\u003cp\u003eWe'll change the \u003ccode\u003eview\u003c/code\u003e function of the \u003ccode\u003eVehicleListing\u003c/code\u003e to be the following:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e    let view (model: Model) dispatch =\n        View.StackLayout\n            (padding = Thickness 5.0,\n             children =\n                 [ View.Frame\n                     (hasShadow = false,\n                      backgroundColor = AppColors.ghostWhite,\n                      padding = Thickness 10.0,\n                      content =\n                          View.FlexLayout\n                              (margin = Thickness 10.0,\n                               verticalOptions = LayoutOptions.Center,\n                               horizontalOptions = LayoutOptions.Center,\n                               alignItems = FlexAlignItems.Center,\n                               justifyContent = FlexJustify.SpaceEvenly,\n                               direction = FlexDirection.Row,\n                               children =\n                                   [ View.SKCanvasView\n                                       (paintSurface =\n                                           (fun args -\u003e\n                                               let info = args.Info\n                                               let surface = args.Surface\n                                               let canvas = surface.Canvas\n\n                                               canvas.Clear()\n\n                                               use paint =\n                                                   new SkiaSharp.SKPaint(Style = SkiaSharp.SKPaintStyle.Fill,\n                                                                         Color =\n                                                                             (if model.IsPrimary then\n                                                                                 AppColors.mandarin.ToSKColor()\n                                                                              else\n                                                                                  AppColors.silverSandLight.ToSKColor()),\n                                                                         StrokeWidth = 5.0f)\n\n                                               canvas.DrawCircle\n                                                   (float32 (info.Width / 2), float32 (info.Height / 2), 10.0f, paint)))\n                                     View.Label(text = model.Year.ToString())\n                                     View.Label(text = model.Make)\n                                     View.Label(text = model.Model) ])) ])\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow thats quite a big difference, so lets break it down real quick.\u003c/p\u003e\n\u003cp\u003eThe basic layout is a \u003ccode\u003eStackLayout\u003c/code\u003e with a single \u003ccode\u003eFrame\u003c/code\u003e as the child. This is done so that we can create space between list elements via padding. The \u003ccode\u003eFrame\u003c/code\u003e's content is a \u003ccode\u003eFlexLayout\u003c/code\u003e which allows us to evenly space the elements horizontally. Finally, we have a dot drawn via SkiaSharp that indicates the which is the primary, along with the reast of the info for the vehicle.\u003c/p\u003e\n\u003cp\u003eThe result looks like this:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/posts/mvu-composition/spiffy-vehicle-list.png\" alt=\"Spiffy Vehicle List\"\u003e\u003c/p\u003e\n\u003cp\u003eI decided to conditionally change the color of the primary indicator instead of hiding it so that things will continue to line up. The alignment and layout isn't perfect, but it feels pretty good so I'm going to leave it alone for now and move on to something more interesting. Lets try to wire up a \u003ccode\u003eSwipeView\u003c/code\u003e so that we can swipe on individual items and mark them as primary.\u003c/p\u003e\n\u003ch1\u003eToggle Primary\u003c/h1\u003e\n\u003cp\u003eSo before we get into the code that changed, I want to say that this was really quite painless to set up. In fact, most of the changes I've made were more improvments than they were \"making it work\". This is largely due to the nature of MVU. Since I spent a little bit of time mapping out what updates I wanted, the logic required to update the model was already there, it just took a little bit of work to finish putting it together. That being said lets dive in.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e    let update msg model =\n        match msg with\n        | Insert -\u003e model //TODO: Make this do something\n        | Remove -\u003e model //TODO: Make this do something\n        | Modified (pos, itemMessage) -\u003e\n            match itemMessage with\n            | VehicleItem.Msg.TogglePrimary isPrimary -\u003e\n                { model with\n                      Vehicles =\n                          model.Vehicles\n                          |\u003e List.mapi (fun i itemModel -\u003e\n                              if i = pos then\n                                  VehicleItem.update itemMessage itemModel\n                              else\n                                  (if isPrimary \u0026#x26;\u0026#x26; itemModel.IsPrimary\n                                   then VehicleItem.update (VehicleItem.TogglePrimary(false)) itemModel\n                                   else itemModel)) }\n        | SelectVehicle pos -\u003e\n            { model with\n                  SelectedVehicle = Some(model.Vehicles.Item(pos)) }\n\n    let view (model: Model) dispatch =\n        let items =\n            model.Vehicles\n            |\u003e List.mapi (fun pos itemModel -\u003e\n                View.SwipeView\n                    (backgroundColor = AppColors.silverSandLight,\n                     rightItems =\n                         View.SwipeItems\n                             (items =\n                                 [ View.SwipeItem\n                                     (text = (if not itemModel.IsPrimary then \"Primary\" else \"Not Primary\"),\n                                      backgroundColor =\n                                          (if not itemModel.IsPrimary then\n                                              AppColors.mandarin\n                                           else\n                                               AppColors.silverSandMediumDark),\n                                      command =\n                                          fun () -\u003e\n                                              dispatch\n                                                  (Modified(pos, VehicleItem.TogglePrimary(not itemModel.IsPrimary)))) ]),\n                     content = VehicleItem.view itemModel (fun msg -\u003e dispatch (Modified(pos, msg)))))\n\n        View.CollectionView(items)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLet's start by looking at the \u003ccode\u003eview\u003c/code\u003e function. Instead of mapping our \u003ccode\u003eVehicleItem.Model\u003c/code\u003e's directly to their \u003ccode\u003eview\u003c/code\u003e function, we wrap them in a \u003ccode\u003eSwipeView\u003c/code\u003e. I think it would have also been feasible to implement the swipe view one step down in the body of \u003ccode\u003eVehicleItem.view\u003c/code\u003e, but it felt right to keep \u003ccode\u003eVehicleItem\u003c/code\u003e to strictly displaying the Vehicle information.\u003c/p\u003e\n\u003cp\u003eYou'll notice that the \u003ccode\u003eSwipeView\u003c/code\u003e contains a \u003ccode\u003eSwipeItem\u003c/code\u003e which has some conditional rendering of the text and background color. This is just so that we can distinguish between adding and removing the \"Primary\" status. I used the \u003ccode\u003eSwipeItem\u003c/code\u003e's command property to fire dispatch and send the appropriate message. Really and truly, I realized that my \u003ccode\u003eModified\u003c/code\u003e message handling is a bit more complicated than it needs to be right now. This is because I'm assuming that \u003ccode\u003eVehicleItem\u003c/code\u003e will eventually require additional messages (for things like updating the Make, Model) and that that logic will need to be \u003cem\u003edifferent\u003c/em\u003e from the logic that handles IsPrimary.\u003c/p\u003e\n\u003cp\u003eThis is primarily for two different reasons. One is that only one vehicle can have \"Primary\" status at a time, so if \"Primary\" status changes for one vehicle, it \u003cem\u003emay\u003c/em\u003e affect the others (this is reflected in the \u003ccode\u003eupdate\u003c/code\u003e function, but we'll get to that in a minute). This is simply not true of other properties like Make, Model, and Year.\u003c/p\u003e\n\u003cp\u003eThe second reason is actually not visible in the above code. There is a small change I made to \u003ccode\u003eVehicleItem\u003c/code\u003e, which basically amounts to forcing SkiaSharp to redraw the little circles on every update. This is fine for right now, because the only reason \u003ccode\u003eVehicleItem.update\u003c/code\u003e is called at the moment is to change \u003ccode\u003eIsPrimary\u003c/code\u003e which requires a redraw of the dot. However, as we add other messages, we will need to make sure we don't redraw on every update as this will result in performance hits.\u003c/p\u003e\n\u003cp\u003eSo this is where we are UI-wise:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/posts/mvu-composition/mark-primary.gif\" alt=\"Mark Primary UI\"\u003e\u003c/p\u003e\n\u003cp\u003eYou'll notice that selecting one as Primary makes the other not primary (if it already was). This logic is handled in our \u003ccode\u003eupdate\u003c/code\u003e function. Our \u003ccode\u003eModified\u003c/code\u003e message contains the position and the \u003ccode\u003eVehicleItem.Msg\u003c/code\u003e we want to pass on to \u003ccode\u003eVehicleItem.update\u003c/code\u003e. Now we could for the time being have made \u003ccode\u003eModified\u003c/code\u003e to contain the \u003ccode\u003eTogglePrimary\u003c/code\u003e message instead of any \u003ccode\u003eVehicleItem.Msg\u003c/code\u003e, because for now that's the only message that \u003ccode\u003eVehicleItem\u003c/code\u003e has, but as I said earlier, this will allow us to handle future scenarios where we want to edit other information. So we pattern match on \u003ccode\u003eitemMessage\u003c/code\u003e and handle the only existing case (where \u003ccode\u003eitemMessage\u003c/code\u003e is the \u003ccode\u003eTogglePrimary\u003c/code\u003e message).\u003c/p\u003e\n\u003cp\u003eWe are also no longer simply calling \u003ccode\u003eVehicleItem.update\u003c/code\u003e on the item that matches the position we were given. We're also checking if we're setting a new item as Primary and mark any other items that are currently \"Primary\" to false. This will ensure that only one item is ever marked as Primary at a time.\u003c/p\u003e\n\u003cp\u003eBefore we wrap things up, I want to mention that I \u003cem\u003ethink\u003c/em\u003e this validates my assumption that we can handle \"Selecting\" a particular vehicle item within \u003ccode\u003eVehicleListing\u003c/code\u003e. We should be able to call dispatch to send a selection message from a \u003ccode\u003eSwipeItem\u003c/code\u003e.\u003c/p\u003e\n\u003ch1\u003eWrapping Up\u003c/h1\u003e\n\u003cp\u003eSo I think this is the state I'll leave the app in for the purposes of this article. I think it gives a pretty good idea of how composition in MVU can allow us to break out parts of the UI into smaller units. So I guess the question is, what did we learn from this?\u003c/p\u003e\n\u003cp\u003eMy first big take away is that this architecture is so straight forward that it was fairly easy for me to do a lot of planning ahead without really having a super great understanding of how all the pieces would fit together. For instance, I was pleasantly surprised by how decisions I made when creating \u003ccode\u003eVehicleItem\u003c/code\u003e panned out when connecting them to \u003ccode\u003eVehicleListing\u003c/code\u003e. The simplicity of this framework really does allow you to think clearly and accurately about what changes should and will occur to the model as well as what the resulting UI will look like.\u003c/p\u003e\n\u003cp\u003eI will note that I did not do any Commanding, which I think will complicate matters when it is needed, but the beautify of this framework is that its not necessary so far, so I didn't have to use it.\u003c/p\u003e\n\u003cp\u003eI'd also like to take this time to mention that I did have certain struggles with using additional libraries. One thing I've come to realize is that there isn't a lot of documentation for Fabulous and that examples of F# code in general are hard to find. This can make it difficult to learn, but also frustrating for someone who is used to being able to \"just read the docs\".\u003c/p\u003e\n\u003cp\u003eAnother thing I'd like to note is that quite frankly, 3rd party support for F# in Xamarin.Forms basically does not exist. I had wanted to use Sharpnado's MaterialFrame so I could get the Acrylic look, but quickly found out that MaterialFrame is built to be used strictly in XAML. This was a bit disappointing, but ultimately not a big deal. My hope is that with .NET MAUI, we'll start to see some of these UI tools become more \"Functional Friendly\" with built in support that goes beyond data binding and MVVM.\u003c/p\u003e\n\u003cp\u003eI do plan to continue working on this project, but I think this will be my last blog on it for a while. I need to spend some more time digging in to F# and MVU so that I can really understand it and find some interesting ways to use it, before I can share any more insights.\u003c/p\u003e\n\u003cp\u003eIn the meantime, go give us some listens and feel free to reach out in the comments below, on Twitter \u003ca href=\"twitter.com/usecasepod\"\u003e@usecasepod\u003c/a\u003e, or \u003ca href=\"mailto:usecasepod@gmail.com\"\u003evia email (usecasepod@gmail.com)\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eYou can also find the full repository for this app \u003ca href=\"https://github.com/usecasepod/commutr_v2\"\u003eon our Github\u003c/a\u003e, but keep in mind that this is going to be a living project, so what you see in this post today may not be reflected in the current version of the app.\u003c/p\u003e\n","date":"2020-05-24","excerpt":"\u003cp\u003eSo a couple days have come and gone and I'm still riding high on my experience with the MVU pattern. I'm struggling some with the syntax of F#, but I'm getting it bit by bit and even learning to love some aspects of it. That being said, the sample app I went through last time did nothing but peak my interest. It felt really smooth and easy to reason about, but \"Counters\" always are, right? So the next logical question is, how do we make this work for a more complicated situation?\u003c/p\u003e\n"}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"2020-05-24-mvu-composition"},"buildId":"W8uwEbnihAL2hkzDM9xWg","assetPrefix":"/nextjs-blog","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>