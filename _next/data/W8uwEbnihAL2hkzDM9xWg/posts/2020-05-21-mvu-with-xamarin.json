{"pageProps":{"post":{"title":"Exploring MVU and Functional Paradigms in Xamarin.Forms","slug":"2020-05-21-mvu-with-xamarin","author":"Austin Webre","content":"<p>This week saw one of Microsoft's biggest conferences transition to a completely online format. We won't discuss the fact that this year's conference was <strong>supposed</strong> to be held just 30 minutes from my house and that I was hoping to attend, but I do want to talk a bit about some of this year's announcements in the .NET space that have taken over my brain. There's plenty to be excited about - <a href=\"https://azure.microsoft.com/en-us/blog/azure-analytics-clarity-in-an-instant/\">new Azure services</a>, <a href=\"https://visualstudiomagazine.com/articles/2020/05/19/blazor-webassembly-3-2.aspx\">production-ready (?) Blazor</a>, <a href=\"https://devblogs.microsoft.com/dotnet/announcing-net-5-preview-4-and-our-journey-to-one-net/\">.NET Core 4 - err... I mean .NET 5</a> - but what has really monopolized my thinking is how functional concepts keep making their way into C#.</p>\n<p>I found this in two distinct efforts that were mentioned at this year's Build. The more obvious of the two is the <a href=\"https://devblogs.microsoft.com/dotnet/welcome-to-c-9-0/\">addition of Records and Init-only Properties in C# 9.0</a>. This, along with some nice improvments to pattern matching, will mean that C# devs will be able to reap some more of the performance and readability benefits of a more Functional approach. The second place, was with the introduction of a technology that is still a year out from its first GA version: <a href=\"https://devblogs.microsoft.com/dotnet/introducing-net-multi-platform-app-ui/\">.NET MAUI (Multi-platform App UI)</a>. The idea here is to finally unify the split Xamarin/UWP experiences into a single developer experience. Now, this on its own is really cool (<strong><em>IOS, ANDROID, AND WINDOWS ALL IN THE SAME PROJECT?!?! GASP</em></strong>), but they snuck something in here that again appears to point towards Functional paradigms coming enmasse to C#-land, namely, first class support for MVU (Model-View-Update).</p>\n<p>Now C# devs are really familiar with M's and V's - we're all about MVC and MVVM - but I don't think very many of us are familiar with MVU. I've heard it discussed by people who have their toes in the Functional world, but never really dug in. In fact, I've always wanted to be one of those people that has their toes in the Functional world, but I've always given up long before I understood anything in a real sense. So I've convinced myself to give it another try, but this time in the hopes that I might get some insight into the future of mobile development on the .NET platform.</p>\n<p>So that's the plan (and the purpose of this article - only took me 3 paragraphs to get to it).\nI'm going to use F# and Xamarin.Forms to try out MVU in the hopes that I might gain some insight into what MAUI may bring.</p>\n<p>This may be a completely foolish attempt, but I think it has the highest possibility of getting me to actually try my hand at F#. Worst case, you'll never see this, because I'll never post it. Its a perfect system.</p>\n<h1>Fabulous F# and Xamarin.Forms</h1>\n<p>Anyway, I started by doing some googling for MVU frameworks meant to work with Xamarin.Forms and within seconds I had run into <a href=\"https://github.com/fsprojects/Fabulous/tree/master/Fabulous.XamarinForms\">Fabulous for Xamarin.Forms</a>. It looked like everything I needed, including a template project - which was a real plus. I won't bore you with the setup, just know that it was minimal (a couple of dotnet CLI commands) and that it resulted in this:\n<img src=\"/assets/posts/mvu-with-xamarin/solution-tree.png\" alt=\"Solution Tree\"></p>\n<p>Thats right folks, three F# projects, no XAML, and no C#.</p>\n<blockquote>\n<h4>Side Note: Project Name</h4>\n<p>You may be questioning why this project name is not \"MvuDemo\" or \"HelleWorldMvu\" or something. My plan is to ultimately recreate an app that I wrote a few years ago, which I use for mileage and fuel economy tracking. While its not important to this particular post, I figured I'd let you all in on this little personality tick of mine. When I start a project of any kind, I start with an end goal so large its impossible.</p>\n<p>There's a good chance <em>commutrv2</em> will never actually happen. When I first started this post, I assumed I would be able to get well beyond explaining the demo app. I quickly realized I needed to break down the demo app just so that I could understand it. So there you have it. When it comes to personal goals, I <em>always</em> over promise and under deliver.</p>\n</blockquote>\n<p>Was that a waste of your time? I hope not ... now where were we?</p>\n<p>Oh right, here's the contents of the single F# file generated in the shared project:</p>\n<pre><code>// Copyright 2018-2019 Fabulous contributors. See LICENSE.md for license.\nnamespace commutr_v2\n\nopen System.Diagnostics\nopen Fabulous\nopen Fabulous.XamarinForms\nopen Fabulous.XamarinForms.LiveUpdate\nopen Xamarin.Forms\n\nmodule App =\n    type Model =\n      { Count : int\n        Step : int\n        TimerOn: bool }\n\n    type Msg =\n        | Increment\n        | Decrement\n        | Reset\n        | SetStep of int\n        | TimerToggled of bool\n        | TimedTick\n\n    let initModel = { Count = 0; Step = 1; TimerOn=false }\n\n    let init () = initModel, Cmd.none\n\n    let timerCmd =\n        async { do! Async.Sleep 200\n                return TimedTick }\n        |> Cmd.ofAsyncMsg\n\n    let update msg model =\n        match msg with\n        | Increment -> { model with Count = model.Count + model.Step }, Cmd.none\n        | Decrement -> { model with Count = model.Count - model.Step }, Cmd.none\n        | Reset -> init ()\n        | SetStep n -> { model with Step = n }, Cmd.none\n        | TimerToggled on -> { model with TimerOn = on }, (if on then timerCmd else Cmd.none)\n        | TimedTick ->\n            if model.TimerOn then\n                { model with Count = model.Count + model.Step }, timerCmd\n            else\n                model, Cmd.none\n\n    let view (model: Model) dispatch =\n        View.ContentPage(\n          content = View.StackLayout(padding = Thickness 20.0, verticalOptions = LayoutOptions.Center,\n            children = [\n                View.Label(text = sprintf \"%d\" model.Count, horizontalOptions = LayoutOptions.Center, width=200.0, horizontalTextAlignment=TextAlignment.Center)\n                View.Button(text = \"Increment\", command = (fun () -> dispatch Increment), horizontalOptions = LayoutOptions.Center)\n                View.Button(text = \"Decrement\", command = (fun () -> dispatch Decrement), horizontalOptions = LayoutOptions.Center)\n                View.Label(text = \"Timer\", horizontalOptions = LayoutOptions.Center)\n                View.Switch(isToggled = model.TimerOn, toggled = (fun on -> dispatch (TimerToggled on.Value)), horizontalOptions = LayoutOptions.Center)\n                View.Slider(minimumMaximum = (0.0, 10.0), value = double model.Step, valueChanged = (fun args -> dispatch (SetStep (int (args.NewValue + 0.5)))), horizontalOptions = LayoutOptions.FillAndExpand)\n                View.Label(text = sprintf \"Step size: %d\" model.Step, horizontalOptions = LayoutOptions.Center)\n                View.Button(text = \"Reset\", horizontalOptions = LayoutOptions.Center, command = (fun () -> dispatch Reset), commandCanExecute = (model &#x3C;> initModel))\n            ]))\n\n    // Note, this declaration is needed if you enable LiveUpdate\n    let program = XamarinFormsProgram.mkProgram init update view\n\ntype App () as app =\n    inherit Application ()\n\n    let runner =\n        App.program\n#if DEBUG\n        |> Program.withConsoleTrace\n#endif\n        |> XamarinFormsProgram.run app\n\n#if DEBUG\n    // Uncomment this line to enable live update in debug mode.\n    // See https://fsprojects.github.io/Fabulous/Fabulous.XamarinForms/tools.html#live-update for further  instructions.\n    //\n    do runner.EnableLiveUpdate()\n#endif\n\n    // Uncomment this code to save the application state to app.Properties using Newtonsoft.Json\n    // See https://fsprojects.github.io/Fabulous/Fabulous.XamarinForms/models.html#saving-application-state for further  instructions.\n#if APPSAVE\n    let modelId = \"model\"\n    override __.OnSleep() =\n\n        let json = Newtonsoft.Json.JsonConvert.SerializeObject(runner.CurrentModel)\n        Console.WriteLine(\"OnSleep: saving model into app.Properties, json = {0}\", json)\n\n        app.Properties.[modelId] &#x3C;- json\n\n    override __.OnResume() =\n        Console.WriteLine \"OnResume: checking for model in app.Properties\"\n        try\n            match app.Properties.TryGetValue modelId with\n            | true, (:? string as json) ->\n\n                Console.WriteLine(\"OnResume: restoring model from app.Properties, json = {0}\", json)\n                let model = Newtonsoft.Json.JsonConvert.DeserializeObject&#x3C;App.Model>(json)\n\n                Console.WriteLine(\"OnResume: restoring model from app.Properties, model = {0}\", (sprintf \"%0A\" model))\n                runner.SetCurrentModel (model, Cmd.none)\n\n            | _ -> ()\n        with ex ->\n            App.program.onError(\"Error while restoring model found in app.Properties\", ex)\n\n    override this.OnStart() =\n        Console.WriteLine \"OnStart: using same logic as OnResume()\"\n        this.OnResume()\n#endif\n</code></pre>\n<p>This is a pretty complicated example to start with, and it took me a little bit by surprise. But the gist of this example is that it is a counter, with a slider to adjust the \"step\" of the increment, and an optional timer feature which increments the count by the step amount every 200ms. Here's the UI to help you picture it.</p>\n<p><img src=\"/assets/posts/mvu-with-xamarin/initial-example-screenshot.png\" alt=\"(Initial Example Screenshot)\"></p>\n<blockquote>\n<h4>Side Note: Acknowledging My Own Limits</h4>\n<p>Just as a note, we're going to skip everything from <code>let program = XamarinFormsProgram.mkProgram init update view</code> down as this is really just kind of \"wiring\" that sets up the framework. I included it here as it is part of the file and might be interesting for those who are a little more advanced in their knowledge of F# Xamarin development, but - to be truthfully honest - I don't understand most of it.</p>\n</blockquote>\n<h1>Breaking It Down</h1>\n<p>Now I know there's a lot of code here and on top of that, there's quite a bit of syntax that looks quite strange if you're not familiar with F#, but there's really three key portions of this app that I think break down quite nicely. I know what you're thinking, \"Three you say? You mean the same as the number of letters in the acronym?\" And you're right, but you don't have to be so smug about it.</p>\n<h2>First: The Model (and the Initialization Thereof)</h2>\n<pre><code>    type Model =\n      { Count : int\n        Step : int\n        TimerOn: bool }\n\n    type Msg =\n        | Increment\n        | Decrement\n        | Reset\n        | SetStep of int\n        | TimerToggled of bool\n        | TimedTick\n\n    let initModel = { Count = 0; Step = 1; TimerOn=false }\n\n    let init () = initModel, Cmd.none\n</code></pre>\n<p>In the above, we have two types. One is a record representing the data that will drive the app, and we've decided to call it <code>Model</code> (because its... the model). But the second one is actually what we call a Discriminated Union. The best description I've heard so far of Discriminated Unions is that they're \"enums on steroids\". They are similar to an enum where each value can be an \"object\" and they're really powerful. Anyway, all that syntax aside, this Discriminated Union is what we call the message. The importance of the message is that it tells us how the model should change. For those familiar with tools like ReactRedux, the message is similar to your action.</p>\n<p>Next we have two <code>let</code> statements. The first describes the initial state. Notice that we do not specify that it is of the <code>Model</code> type, because types are inferred in F#. Its magic and its a lot less typing, and I'm not sure if I love it or hate it. The second let statement is essential, it is a function that returns the intial state (which we created in the previous statement) and a command. Commands are another key concept in MVU.</p>\n<p>As I understand it, the key reason for having commands is that they allow us to fire messages from within the update function (which we will discuss in more detail later). But there are several different kinds of commands which can be used to fire messages in different kinds of ways.The one you'll see used in this example is <code>Cmd.ofAsyncMsg</code>. TThis command allow asynchrous messages to be piped in to our update function, which allows us to complete asynchronous tasks like waiting on a timer, making a database call, or issuing and resolving a REST request. I'm skipping ahead a bit here, but this should make more sense in a minute.</p>\n<p>So there we have it, the model, the message, and our initalizer.</p>\n<h2>Next Up: Our Update Function</h2>\n<pre><code>   let timerCmd =\n        async { do! Async.Sleep 200\n                return TimedTick }\n        |> Cmd.ofAsyncMsg\n\n    let update msg model =\n        match msg with\n        | Increment -> { model with Count = model.Count + model.Step }, Cmd.none\n        | Decrement -> { model with Count = model.Count - model.Step }, Cmd.none\n        | Reset -> init ()\n        | SetStep n -> { model with Step = n }, Cmd.none\n        | TimerToggled on -> { model with TimerOn = on }, (if on then timerCmd else Cmd.none)\n        | TimedTick ->\n            if model.TimerOn then\n                { model with Count = model.Count + model.Step }, timerCmd\n            else\n                model, Cmd.none\n</code></pre>\n<p>So in the above, we only have two statements. <code>timerCmd</code> is an asynchronous function which waits 200ms before returning a <code>TimedTick</code>, which you may recall was one of the cases in our Discriminated Union. This is then piped into an async message command, which will issue the <code>TimedTick</code> message when it is returned by our async call. The <code>|></code> (forward pipe) syntax is another thing that feels really strange, but it allows you to chain together functions quickly and with minimal fuss.</p>\n<p>Next you'll find the real substance of our apps logic, the update function. <code>update</code> take in two parameters <code>msg</code> and <code>model</code>. Simply put, <code>model</code> tells us the current state of the app and <code>msg</code> tells us what action we should perform on that state. By pattern matching on <code>msg</code> we can call different functions based on the message we received. Note that the function should have the same return as our <code>init</code> function from earlier: the updated model, and a command to call (if any).</p>\n<p>I think most of these are self explanatory (assuming you understand the <code>with</code> syntax, which creates a copy of the object with whatever changes are specificed): Increment returns the current model with count increased by the current Step amount, decement does the opposite, etc. But the last two cases are where you can see everything come together.</p>\n<p>In the case where <code>msg</code> is <code>TimerToggled</code>, we return the model with an update to the <code>TimerOn</code> field with the value that we were supplied. As for the command, we return <code>timerCmd</code> if the value of <code>TimerOn</code> is <code>true</code> and no command if not.</p>\n<p>The last case - where <code>msg</code> is <code>TimedTick</code> - is the message sent when <code>timerCmd</code> has completed. If the timer is on, we want to update the count by step and call <code>timerCmd</code> again. This puts us in a loop where the <code>timerCmd</code> is called, count is updated and then its called again. We can break this loop, by sending the <code>TimerToggled</code> message with a value of <code>false</code>.</p>\n<p>So that's the update function. At its core, its a reducer that applies changes to the state based on the message that is sent. Again if you're familiar with ReactRedux, you've seen this before.</p>\n<h2>Finally: The View</h2>\n<pre><code>    let view (model: Model) dispatch =\n        View.ContentPage(\n          content = View.StackLayout(padding = Thickness 20.0, verticalOptions = LayoutOptions.Center,\n            children = [\n                View.Label(text = sprintf \"%d\" model.Count, horizontalOptions = LayoutOptions.Center, width=200.0, horizontalTextAlignment=TextAlignment.Center)\n                View.Button(text = \"Increment\", command = (fun () -> dispatch Increment), horizontalOptions = LayoutOptions.Center)\n                View.Button(text = \"Decrement\", command = (fun () -> dispatch Decrement), horizontalOptions = LayoutOptions.Center)\n                View.Label(text = \"Timer\", horizontalOptions = LayoutOptions.Center)\n                View.Switch(isToggled = model.TimerOn, toggled = (fun on -> dispatch (TimerToggled on.Value)), horizontalOptions = LayoutOptions.Center)\n                View.Slider(minimumMaximum = (0.0, 10.0), value = double model.Step, valueChanged = (fun args -> dispatch (SetStep (int (args.NewValue + 0.5)))), horizontalOptions = LayoutOptions.FillAndExpand)\n                View.Label(text = sprintf \"Step size: %d\" model.Step, horizontalOptions = LayoutOptions.Center)\n                View.Button(text = \"Reset\", horizontalOptions = LayoutOptions.Center, command = (fun () -> dispatch Reset), commandCanExecute = (model &#x3C;> initModel))\n            ]))\n</code></pre>\n<p>The view function returns the UI based on the current state. The view function should always be <strong>pure</strong>, meaning that it should contain no side effects and should always return the same output with the same input. In this example, we're using the standard Xamarin.Forms UI elements to render a Content Page with a Stack Layout. The children of the stack layout, are a Label for the count, a Button for increment and decrement, etc.</p>\n<p>Notice that <code>view</code> takes two arguments, <code>model</code> and <code>dispatch</code>. As with everywhere else, <code>model</code> is the current state of our app. The second argument, <code>dispatch</code> is a special function that allows us to send messages to our update function.</p>\n<p>There are a few places where <code>dispatch</code> is used. The \"Increment\" button dispatches an <code>Increment</code> message, on each click. The \"Timer\" switch, displays the current state of <code>model.TimerOn</code> and dispatches the <code>TimerToggled</code> message with the updated value when it is toggled. The slider calls <code>SetStep</code> based on the value of slider as it changes.</p>\n<p>In each case, the UI element displays the current state of the Model (where necessary) and uses <code>dispatch</code> to send messages to <code>update</code>. This is the magic of MVU. Data flows in a very linear fashion, as the current state is passed to the view and the view dispatches an update. Rinse, repeat. (So I guess its more of a <em>circular</em> flow?)</p>\n<h1>Final Thoughts</h1>\n<p>There are plenty of things I don't like about F#. For one, I think that its easy for a language that encourages <em>less code</em> to encourage less readability. At the same time, I recognize that <em>more verbose</em> does not necessarily equal <em>more readable</em>, so... to each their own. What I really like about this approach is the same thing I have come to love about functional components in React (which is the only other \"functional\" environment that I regularly interact with). Because the view can only read the current state and dispatch updates to the state, its very easy to reason about what happens in any given scenario.</p>\n<p>That's what excites me about MAUI. If the result is MVU's ability to make code more \"reasonable\" with the familiarity of C#, I really think I could be sold on it. The beauty of all this is that there are no plans to get rid of XAML or MVVM, so I'll always have that to fall back on, but I think there is really something to be said for the simplicity of MVU. That being said, this is just me scratching the surface. In order to do a full scale app (like Commutr V2), I'll have to figure out how to leverage composition to create smaller, more manageable components that can be combined together to accomplish complicated tasks.</p>\n<p>But that's for a another day. 'Til next time!</p>\n<p>(If I ever get around to it...)</p>\n<hr>\n<p>Turns out I did get around to it. Go check out <a href=\"/posts/mvu-composition.html\">Exploring MVU Part 2: Composition</a>.</p>\n","date":"2020-05-21","excerpt":"<p>This week saw one of Microsoft's biggest conferences transition to a completely online format. We won't discuss the fact that this year's conference was <strong>supposed</strong> to be held just 30 minutes from my house and that I was hoping to attend, but I do want to talk a bit about some of this year's announcements in the .NET space that have taken over my brain. There's plenty to be excited about - <a href=\"https://azure.microsoft.com/en-us/blog/azure-analytics-clarity-in-an-instant/\">new Azure services</a>, <a href=\"https://visualstudiomagazine.com/articles/2020/05/19/blazor-webassembly-3-2.aspx\">production-ready (?) Blazor</a>, <a href=\"https://devblogs.microsoft.com/dotnet/announcing-net-5-preview-4-and-our-journey-to-one-net/\">.NET Core 4 - err... I mean .NET 5</a> - but what has really monopolized my thinking is how functional concepts keep making their way into C#.</p>\n"}},"__N_SSG":true}